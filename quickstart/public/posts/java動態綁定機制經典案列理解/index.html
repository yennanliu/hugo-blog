<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Java動態綁定機制經典案列理解 | K dev blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.121.1">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="https://example.org/posts/java%E5%8B%95%E6%85%8B%E7%B6%81%E5%AE%9A%E6%A9%9F%E5%88%B6%E7%B6%93%E5%85%B8%E6%A1%88%E5%88%97%E7%90%86%E8%A7%A3/">
    

    <meta property="og:title" content="Java動態綁定機制經典案列理解" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.org/posts/java%E5%8B%95%E6%85%8B%E7%B6%81%E5%AE%9A%E6%A9%9F%E5%88%B6%E7%B6%93%E5%85%B8%E6%A1%88%E5%88%97%E7%90%86%E8%A7%A3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-12T15:50:58+00:00" />
<meta property="article:modified_time" content="2024-02-12T15:50:58+00:00" />

<meta itemprop="name" content="Java動態綁定機制經典案列理解">
<meta itemprop="description" content=""><meta itemprop="datePublished" content="2024-02-12T15:50:58+00:00" />
<meta itemprop="dateModified" content="2024-02-12T15:50:58+00:00" />
<meta itemprop="wordCount" content="82">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Java動態綁定機制經典案列理解"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        K dev blog
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">Java動態綁定機制經典案列理解</h1>
      
      <p class="tracked">
        By <strong>K</strong>
      </p>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2024-02-12T15:50:58Z">February 12, 2024</time>
      

      
      
                <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1594395063065811"
     crossorigin="anonymous"></script>
     
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>如題，直接帶入案例進行理解Java的動態綁定機制，不多說直接上代碼了。
輸出內容：
以上代碼不難理解，就是簡單的計算罷了。
但是我們改一下代碼，看看下面的內容：
把classB裏的sum方法註釋了，返回的結果會是什麼呢？
輸出內容：
爲什麼第一個輸出內容變了呢？
這裏就涉及到了Java的動態綁定機制了，大概是這樣的：
所以，以上第一個輸出30大致是這樣的一個流程：因爲classB註釋了sum()，則首先調用的是classA的sum()，而後有調用getI()，這是調用方法，就與new classB()進行了動態綁定，則使用綁定classB裏的getI()，結果就是 20+10=30。
然後再次修改一下代碼：
輸出內容是：
那下面那個爲什麼會輸出20呢？
這是因爲把classB裏的sum1()註釋了，調用的是classA的sum1()，方法裏調用的i屬性，則不會進行動態綁定，直接調用classA的i，結果就是：10 + 10 = 20。</p>
<p>背景
spring和mybatis集成過程中，我們可以通過MapperFactoryBean的方式配置Mapper接口。但是這樣需要在配置文件中，爲每個mapper配置相同的代碼塊，浪費時間。關鍵對於代碼潔癖的人來說，一點不能忍。
&lt;bea</p>
<p>爲什麼要研究字符串？ 人機交互的過程中，文字、數字、字母、符號都是字符表現形式，這部分內容佔了人機信息交互的大部分內容，所以有必要明確一些基本問題。因此大部分數據類型都應該有字符串表達形式，我們在定義新類型的時候可以根據需要來定義新類型的</p>
<p>security的簡單原理：
使用衆多的攔截器對url攔截，以此來管理權限。但是這麼多攔截器，不可能對其一一來講，主要講裏面核心流程的兩個。
首先，權限管理離不開登陸驗證的，所以登陸驗證攔截器AuthenticationProcessing</p>
<p>我們經常會需要啓動多個實例的情況來測試註冊中心、配置中心等基礎設施的高可用，也會用來測試客戶端負載均衡的調用等。但是，我們一個應用只能有一個端口號，這就使得在本機測試的時候，不得不爲同一個服務設置不同的端口來進行啓動。
在本地用不同端口啓動</p>
<p>簡介
    Java Reflection，稱爲 Java 反射，是Java基礎部分的一個比較難的點。Reflection（反射）是被視爲動態語言的關鍵，通過反射機制，我們可以在運行時（runtime）獲取類的完整結構。例如，可以獲取到</p>
<p>一面</p>
<ol>
<li>簡短自我介紹</li>
<li>事務的ACID，其中把事務的隔離性詳細解釋一遍</li>
<li>髒讀、幻影讀、不可重複讀</li>
<li>紅黑樹、二叉樹的算法</li>
<li>平常用到哪些集合類？ArrayList和LinkedList區別？HashMap內部數據結構</li>
</ol>
<p> 
當我們站在技術之路的原點，未來可能充滿了迷茫，也存在着很多不同的可能。在這個知識爆炸與終身學習/碎片化學習爲主的時代，我們面臨的問題之一就是如何進行有效學習，不僅能有效平衡廣度與深度，並且能真正的積澱下來，提升自己的研發效能。於筆者而</p>
<p>阿里巴巴Java開發手冊 梳理筆記 - finally 塊必須對資源對象、流對象進行關閉
規約內容：
2.1 異常處理
6. 【強制】 finally 塊必須對資源對象、流對象進行關閉，有異常也要做 try - catch 。
說明：如果</p>
<p>在Java方面，能夠實現多線程安全修改對象值得方法只有2個
1.原子操作
2.互斥方法
而在Java當中，或是其他語言中，基本上也都是使用CAS實現。CAS是比較並交換的意思，這個操作包含2個連續的操作，比較，還有賦值，因爲2個操作在cpu</p>
<p>單線程輪詢並執行任務，有可能會導致飢餓。比較適合於一些具有一個任務的週期調度。
任務列表用數組存儲，元素最前面的元素是最先被執行的任務。
schedule方法是固定間隔執行，根據上一次執行的結束時間來定義間隔的開始時間
scheduleAt</p>
<p>創建的ReadWriteLock需要使用兩個方法來繼續創造2個對象，分別是ReadLock和WriteLock。
這兩個鎖對象的方法調用都會匯聚到ReadWriteLock的Sync類中。多個對象的方法調用匯聚到一個對象上面，這個設計模式是</p>
<p>synchronized關鍵字可以修飾普通方法，靜態方法，當修飾普通方法，鎖對象是當前對象，當修飾靜態方法，鎖對象是當前類的class
synchroinzed關鍵字可以使用同步代碼塊實現同步，此時可以指定鎖對象。
同步方法的實現方式
同步</p>
<p>AQS是Java多線程編程的重入鎖，管程，工具類的基礎類，是必須要掌握的。不掌握這個類，根本不能稱之爲合格的Java程序員。
即使是把這個類所有的代碼都背會，也是值得的。
如何標識已經有線程在執行呢？
有兩個變量，一個state變量，一個e</p>
<p>################這是之前的思考
內存屏障只是保證清空流水線，如何保證高速緩存的內容更新到最新或刷新到主存呢？這個問題突然想到了，不知道這個需要怎回答。
內存屏障保證的CPU執行執行序列能夠順序執行，而不是亂序執行。當然，前提</p>
<p>使用volidate關鍵字修飾的成員變量，保證可見性，也就是當一個線程修改這樣的成員變量後，其他的線程能夠立即看到這次的修改。有兩個方面的原因：
1.編譯器不優化對這樣的關鍵字修飾變量的一些訪問操作
2.對讀，寫這個關鍵字修飾的變量前後，會</p><ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://example.org/" >
    &copy;  K dev blog 2024 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
